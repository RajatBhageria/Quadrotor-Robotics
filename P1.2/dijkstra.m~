function [path, num_expanded] = dijkstra(map, start, goal, astar)
% DIJKSTRA Find the shortest path from start to goal.
%   PATH = DIJKSTRA(map, start, goal) returns an M-by-3 matrix, where each row
%   consists of the (x, y, z) coordinates of a point on the path.  The first
%   row is start and the last row is goal.  If no path is found, PATH is a
%   0-by-3 matrix.  Consecutive points in PATH should not be farther apart than
%   neighboring cells in the map (e.g.., if 5 consecutive points in PATH are
%   co-linear, don't simplify PATH by removing the 3 intermediate points).
%
%   PATH = DIJKSTRA(map, start, goal, astar) finds the path using euclidean
%   distance to goal as a heuristic if astar is true.
%
%   [PATH, NUM_EXPANDED] = DIJKSTRA(...) returns the path as well as
%   the number of points that were visited while performing the search.
if nargin < 4
    astar = false;
end

grid = map.occgrid;
[i,j,k] = size(grid); 
%safeDistance = map.margin; 

%initialize the matrices 
path = [];
num_expanded = 0;
distances = ones(i,j,k)*1000000;
parents = zeros(i,j,k); 

%create a list of the unvisited nodes
unvisited = ones(i,j,k); 
unvisited = unvisited .* ~grid; %shows one where it's possible to go

%initialization of algorithm
startIJK = map.xyzToSub(start);
iStart = startIJK(1); 
jStart = startIJK(2); 
kStart = startIJK(3);   
distances(iStart,jStart,kStart) = 0; 

%main loop 
while (pathFound(goal,unvisited,map) && findMinPath(unvisited,distances) <= 1000000)
    [minNodeVal,indexMinNode] = findMinPath(unvisited, distances);
    unvisited(indexMinNode) = 0; %set as visited 
    
    coordsOfNode = map.indToXYZ(indexMinNode);
    xNode = coordsOfNode(1); 
    yNode = coordsOfNode(2); 
    zNode = coordsOfNode(3); 
    
    %find all the neighbors of the min node 
    neighborsOfMin = findNeighbors(indexMinNode); 
    
    %loop through all the neighbors of the minNode
    for node = 0:size(neighborsOfMin,1)
        %check if the nodes are possible or not
        [xNeighbor,yNeighbor,zNeighbor] = neighborsOfMin(node);
        if (nodeIsPossible(xNeighbor,yNeighbor,zNeighbor,i,j,k))
            costOfPath = ((xNode-xNeighbor)^2+(yNode-yNeighbor)^2 +(zNode-zNeighbor)^2)^.5;
            newDist = distances(xNode,yNode,zNode) + costOfPath; 
            if (newDist < distances(xNeighbor,yNeighbor,zNeighbor))
                distances(xNeighbor,yNeighbor,zNeighbor) = newDist; 
                parents(xNeighbor,yNeighbor,zNeighbor) = indexMinNode; 
            end 
        end 
        
    end 
    
end

%find the actual path 
path(1,:) = map.xyzToSub(goal);
% counter = 2; 
% while isempty(find(path==start))
%     parent = parents(goal(1),goal(2),goal(3));
%     disp(parent); 
%     coordOfParent = map.subToXYZ(parent); 
%     path(counter,:) = coordOfParent;
%     counter = counter + 1; 
% end
path = flip(path); 

end

function [neighbors] = findNeighbors(indexMinNode)
    coords = map.subToXYZ(indexMinNode); 
    x = coords(1); 
    y = coords(2); 
    z = coords(3); 
    
    neighbors = [x-1,y,z;
                x+1,y,z;
                x,y-1,z;
                x,y+1,z;
                x,y,z-1;
                x,y,z+1;];
   
end 


function [isPossible] = nodeIsPossible(x,y,z,i,j,k)
    isPossible = x > 0 && x < i && y > 0 && y < j && z > 0 && z < k;
end 

function [minNodeValue,index] = findMinPath(unvisited,distances)
    allPossibleVals = unvisited.*distances; 
    allPossibleVals(allPossibleVals==0) = 1000000;
    [minNodeValue,index] = min(allPossibleVals(:)); 
end 

function [pathIsFound] = pathFound(goal,unvisited,map)
    indexOfGoal = map.xyzToInd(goal);
    %pathIsFound = isempty(find(unvisited == indexOfGoal)); 
    pathIsFound = (unvisited(indexOfGoal)==0);
end 